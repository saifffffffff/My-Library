#pragma once

#pragma warning (disable : 4996)

#include <iostream>
#include <iomanip>
#include <fstream>
#include <ctime>
#include <vector>
#include <string>
#include <cmath>
#include <cstdlib>

using namespace std;


enum enPrimeNotPrime { Prime = 1, NotPrime = 2 };
enum enSymbol { CapitalLetter, SmallLetter, SpecialChar, Digit };
 

namespace String {

	bool IsUpper(char c) {
		return (c >= 'A' && c <= 'Z');
	}
	bool IsLower(char c) {
		return (c >= 'a' && c <= 'z');
	}
	bool IsPunct(char c) {
		if ((33 <= c && c <= 47) || (58 <= c && c <= 64) || (123 <= c && c <= 126))
			return true;
		return false;
	}
	char ToLower(char c) {
		return IsUpper(c) ? c + 32 : c;
	}
	char ToUpper(char c) {
		return IsLower(c) ? c - 32 : c;
	}
	int Len(string word) {
		int counter = 0;
		while (true) {
			if (word[counter] == '\0')
				break;
			counter++;
		}
		return counter;
	}
	string SubString(string word, short from, short to = 0) {
		if (to == 0) to = Len(word) - 1;
		string subWord = "";
		for (short index = from; index <= to; index++)
			subWord += word[index];
		return subWord;
	}
	char LastChar(string word) {
		return word[Len(word) - 1];
	}
	string CleanWord(string word) {

		if (Len(word) == 1)
			return word;
		if (word[0] == word[1])
			return CleanWord(SubString(word, 1));

		return (word[0] + CleanWord(SubString(word, 1)));

	}
	string RemoveWordFromString(string text , string word) {
		short pos = 0;
		while ((pos = text.find(word)) != string::npos) {
			text.erase(pos, word.length() + 1);
		}
		return text;
		//if (text.find(word) == string::npos ) return;
		//
		//text.erase(text.find(word) , word.size() + 1);
		//
		//RemoveWordFromString(text, word);
	}
	void SwapWordInString(string & text, string OldWord, string NewWord) {
		
		if (text.find(OldWord) == string::npos ) return ;

		short oldWordPos = text.find(OldWord);
		text.erase(oldWordPos, OldWord.size());
		text.insert(oldWordPos, NewWord);

		
		SwapWordInString(text, OldWord, NewWord);

	}
	void PrintFirstLetterFromEachWord(string text) {

		bool isFirstLetter = true;
		for (int i = 0; i < text.length(); i++)
		{
			if (text[i] != ' ' && isFirstLetter)
				cout << text[i] << " ";
			isFirstLetter = (text[i] == ' ');
		}
	}
	string UpperFirstLetterInEachWord(string text) {
		bool IsFirstLetter = true;
		for (short i = 0; i < text.length(); i++) {
			if (IsFirstLetter && text[i] != ' ') {
				text[i] = ToUpper(text[i]);
				IsFirstLetter = false;
			}
			if (text[i] == ' ')
				IsFirstLetter = true;
		}
		return text;
	}
	string LowerFirstLetterInEachWord(string text) {
		bool IsFirstLetter = true;
		for (short i = 0; i < text.length(); i++) {
			if (IsFirstLetter && text[i] != ' ') {
				text[i] = ToLower(text[i]);
				IsFirstLetter = false;
			}
			if (text[i] == ' ')
				IsFirstLetter = true;
		}
		return text;
	}
	string UpperAllString(string text) {
		for (short i = 0; i < text.length(); i++)
		{
			text[i] = ToUpper(text[i]);
		}
		return text;
	}
	string LowerAllString(string text) {
		for (short i = 0; i < text.length(); i++)
		{
			text[i] = ToLower(text[i]);
		}
		return text;
	}
	char ConvertCase(char c) {
		return IsUpper(c) ? ToLower(c) : ToUpper(c);
	}
	string ConvertAllStringCase(string text) {
		for (int i = 0; i < text.length(); i++) {
			text[i] = ConvertCase(text[i]);
		}
		return text;
	}
	short CountCapitalLetters(string text) {
		short counter = 0;
		for (int i = 0; i < text.length(); i++)
			if (IsUpper(text[i]))
				counter++;
		return counter;
	}
	short CountSmallLetters(string text) {
		short counter = 0;
		for (int i = 0; i < text.length(); i++)
			if (IsLower(text[i]))
				counter++;
		return counter;
	}
	short CountLetters(string text, enSymbol WhatToCount) {
		short counter = 0;
		for (short i = 0; i < text.length(); i++) {
			if (WhatToCount == CapitalLetter && IsUpper(text[i]))
				counter++;
			if (WhatToCount == SmallLetter && IsLower(text[i]))
				counter++;
		}
		return counter;
	}
	short CountChar(string text, char c, bool MatchCase = true) {
		short counter = 0;
		for (int i = 0; i < text.length(); i++)
		{
			if (MatchCase)
			{
				if (text[i] == c)
					counter++;
			}
			else
			{
				if (ToLower(text[i]) == ToLower(c))
					counter++;

			}
		}
		return counter;
	}
	bool IsVowel(char c) {
		char cSmall = ToLower(c);
		return (cSmall == 'a' || cSmall == 'o' || cSmall == 'i' || cSmall == 'u' || cSmall == 'e');
	}
	short CountVowels(string text) {
		short counter = 0;
		for (short i = 0; i < text.length(); i++)
			if (IsVowel(text[i]))
				counter++;
		return counter;
	}
	void PrintVowels(string text) {
		for (short i = 0; i < text.length(); i++)
			if (IsVowel(text[i]))
				cout << text[i] << " ";
	}
	void PrintEachWordInString(string text, string delimiter = " ") {

		string word = "";
		short pos = 0;
		while ((pos = (text.find(delimiter))) != string::npos) {

			word = text.substr(0, pos);
			if (word != "") {
				cout << word << endl;
			}

			text.erase(0, pos + delimiter.length());
		}
		if (text != "")
			cout << text;
	}
	short CountEachWordInString(string text) {
		short pos, counter = 0;
		string word = "", delimiter = " ";

		while ((pos = text.find(delimiter)) != string::npos) {
			word = text.substr(0, pos);
			if (word != "")
				counter++;
			text.erase(0, pos + delimiter.length());
		}

		if (text != "")
			counter++;

		return counter;

	}
	vector <string> SpliteString(string text, string delimiter = " ") {
		string word;
		short pos;
		vector <string> SplitedString;
		while ((pos = text.find(delimiter)) != string::npos) {
			word = text.substr(0, pos);
			if (word != "")
				SplitedString.push_back(word);
			text.erase(0, pos + delimiter.length());
		}
		if (text != "")
			SplitedString.push_back(text);
		return SplitedString;

	}
	string TrimLeft(string text) {
		for (short i = 0; i < text.length(); i++)
		{
			if (text[i] != ' ')
				return text.substr(i);
		}
	}
	string TrimRight(string text) {
		for (short i = text.size() - 1; i >= 0; i--)
			if (text[i] != ' ')
				return text.substr(0, i + 1);
	}
	string Trim(string text) {
		return TrimRight(TrimLeft(text));
	}
	string JoinString(const vector <string>& vString, const string& delimiter) {
		if (vString.empty())
			return "";
		string text = "";
		for (string word : vString) {
			text += word + delimiter;
		}
		return text.substr(0, text.length() - delimiter.length());
	}
	string JoinString(string arr[], const int& size, const string& delimiter) {

		string text = "";

		for (short i = 0; i < size; i++)
			text += arr[i] + delimiter;

		return text.substr(0, text.length() - delimiter.length());
	}
	string ReverseString(const string& text1) {

		string text2 = "";
		vector <string > vString = String::SpliteString(text1);
		vector<string >::iterator iter = vString.end();

		while (iter != vString.begin()) {
			iter--;
			text2 += *iter + " ";
		}

		return Trim(text2);

	}
	string ReplaceWordInString(string text, string wordToReplace, string replaceTo) {
		short pos;
		while ((pos = text.find(wordToReplace)) != string::npos) {
			text.replace(pos, wordToReplace.length(), replaceTo);
		}
		return text;
	}
	string ReplaceWordInStringCustom(string text, string wordToReplace, string replaceTo, bool MatchCase = true) {


		if (text.find(wordToReplace) == string::npos)
			return text;

		vector <string> vString = String::SpliteString(text);

		for (string& word : vString) {
			if (MatchCase)
			{
				if (word == wordToReplace)
					word = replaceTo;
			}
			else {
				if (String::UpperAllString(word) == String::UpperAllString(wordToReplace))
					word = replaceTo;
			}

		}
		return JoinString(vString, " ");
	}
	string RemovePunctuatoins(string text1) {
		string text2 = "";

		for (char& ch : text1) {
			if (!IsPunct(ch))
			{
				text2 += ch;
			}
		}
		return text2;
	}


}

namespace Random {
	int GenerateRandomNumber(int From, int To) {

		int randNum = rand() % (To - From + 1) + From;

		return randNum;

	}
	char GetRandomCharacter(enSymbol symbol) {
		switch (symbol)
		{
		case CapitalLetter:
			return char(GenerateRandomNumber(65, 90));

		case SmallLetter:
			return char(GenerateRandomNumber(97, 122));

		case SpecialChar:
			return char(GenerateRandomNumber(33, 47));

		case Digit:
			return char(GenerateRandomNumber(48, 57));

		default:
			break;
		}
	}
	string GenerateWord(short len, enSymbol symbol) {
		string word = "";

		for (int i = 0; i < len; i++)
			word += GetRandomCharacter(symbol);
		return word;
	}
	string GenerateKey() {
		string key = "";
		key = key + GenerateWord(4, CapitalLetter) + '-';
		key = key + GenerateWord(4, CapitalLetter) + '-';
		key = key + GenerateWord(4, CapitalLetter) + '-';
		key = key + GenerateWord(4, CapitalLetter);
		return key;

	}
	void GenerateKeys(int numberOfKeys) {

		for (int i = 0; i < numberOfKeys; i++) {
			cout << "key [" << i + 1 << "] : " << GenerateKey() << endl;
		}
	}

}

namespace Read{
	double ReadDoubleInRange(double From, double To, string message, string OutOfRangeMessage = "", string InvalidInputMessage = "") {
		double num;
		cout << message;
		cin >> num;
		while (num > To || num < From || cin.fail()) {

			if (cin.fail())
				cout << InvalidInputMessage;
			else
				cout << OutOfRangeMessage;

			cin.clear();
			cin.ignore(INT_MAX, '\n');
			cin >> num;
		}
		return num;
	}
	int ReadIntInRange(int From, int To, string message, string OutOfRangeMessage = "", string InvalidInputMessage = "") {
		int num;
		cout << message;
		cin >> num;
		while (num > To || num < From || cin.fail()) {

			if (cin.fail())
				cout << InvalidInputMessage;
			else
				cout << OutOfRangeMessage;

			cin.clear();

			cin.ignore(INT_MAX, '\n');
			cin >> num;
		}
		return num;
	}
	float ReadFloatInRange(float From, float To, string message, string OutOfRangeMessage = "", string InvalidInputMessage = "") {
		float num;
		cout << message;
		cin >> num;
		while (num > To || num < From || cin.fail()) {

			if (cin.fail())
				cout << InvalidInputMessage;
			else
				cout << OutOfRangeMessage;

			cin.clear();
			cin.ignore(INT_MAX, '\n');
			cin >> num;
		}
		return num;
	}

	int ReadInt(string message, string AlertMessage = "") {
		int num;
		cout << message;
		cin >> num;
		while (cin.fail()) {
			cin.clear();
			cout << AlertMessage;
			cin.ignore(INT_MAX, '\n');
			cin >> num;
		}
		return num;
	}
	double ReadDouble(string message, string AlertMessage = "") {
		double num;
		cout << message;
		cin >> num;
		while (cin.fail()) {
			cin.clear();
			cout << AlertMessage;
			cin.ignore(INT_MAX, '\n');
			cin >> num;
		}
		return num;
	}
	float ReadFloat(string message, string AlertMessage = "") {
		float num;
		cout << message;
		cin >> num;
		while (cin.fail()) {
			cin.clear();
			cout << AlertMessage;
			cin.ignore(INT_MAX, '\n');
			cin >> num;
		}
		return num;
	}
	
	string ReadString(string message) {
		string str = "";

		while (str.empty()) {
			cout << message;
			// ws removes the spaces / tabs / new lines from the input
			getline(cin >> ws, str);
		}

		return String::Trim(str);
	}
	char ReadChar(string message) {
		char c;
		string input = "";
		while (true) {
			cout << message;
			getline(cin >> ws, input);
			if (String::Len(input) == 1) {
				c = input[0];
				break;
			}
		}
		return c;
	}
	bool ReadLine(istream& input, string& line, char delimiter = '\n') {

		line.clear();

		char c;

		while (input.get(c) && c != delimiter) {
			line += c;
		}



		return !line.empty() || !input.eof();


	}

}

namespace Math {
	double MyAbs(double num) {

		if (num >= 0)
			return num;

		else
			return num * -1;


	}
	float GetFractionalpart(float num) {
		return  num - (int)num;
	}
	int MyRound(float num) {

		int intPart = num;
		float fractionalPart = GetFractionalpart(num);

		if (MyAbs(fractionalPart) >= 0.5) {
			if (num > 0)
				return ++intPart;
			else
				return --intPart;
		}
		else
		{
			return intPart;
		}
	}
	int MyFloor(float num) {
		if (num > 0)
			return (int)num;
		else
			return (int)num - 1;
	}
	int MyCeil(float num) {

		float fractionalPart = GetFractionalpart(num);

		if (fractionalPart != 0)
		{
			if (num > 0) {
				return int(num) + 1;
			}
			else {
				return int(num);
			}
		}
		else
			return num;
	}
	float MySqrt(float num) {

		return pow(num, 0.5);
	}
	enPrimeNotPrime CheckPrimeNumber(int num) {
		for (int i = 2; i <= (num / 2); i++)
			if (num % i == 0)
				return NotPrime;
		return Prime;
	}
}

namespace Utility {
	void Swap(int& A, int& B) {


		int temp = A;
		A = B;
		B = temp;

	}
	void Swap(short& A, short& B) {


		short temp = A;
		A = B;
		B = temp;

	}
	void Swap(double & A, double& B) {


		double temp = A;
		A = B;
		B = temp;

	}
	void Swap(float & A, float& B) {


		float temp = A;
		A = B;
		B = temp;

	}
	void Swap(string& A, string& B) {


		string temp = A;
		A = B;
		B = temp;

	}

	string RepeatString(short RepititionTimes, string StringToRepeat) {
		string Line = "";
		for (short i = 0; i < RepititionTimes; i++)
			Line += StringToRepeat;
		return Line;
	}
	string GenerateDashes(short NumberOfDashes) {
		return RepeatString(NumberOfDashes, "_");
	}
	string GenerateSpaces(short NumberOfSpaces) {
		return RepeatString(NumberOfSpaces, " ");
	}
}

namespace Array {
	void ReadArray(int arr[], int& size) {

		cout << "Enter number of elements : ";
		cin >> size;

		string message = "";
		for (int i = 0; i < size; i++) {
			message = "Enter Element [" + to_string(i + 1) + "] : ";
			arr[i] = Read::ReadInt(message,"Invalid input\nPlease enter number : ");
		}
	}
	void PrintArray(int arr[], int size) {
		for (int i = 0; i < size; i++)
			cout << arr[i] << " ";
		cout << endl;
	}
	void FillArrayWithRandomNumbers(int arr[], int size) {
		for (int i = 0; i < size; i++)
			arr[i] = Random::GenerateRandomNumber(-100, 100);
	}
	int FindMaxInArray(int arr[], int size) {
		int maxValue = INT_MIN;
		for (int i = 0; i < size; i++) {
			if (maxValue < arr[i])
				maxValue = arr[i];
		}
		return maxValue;
	}
	int FindMinInArray(int arr[], int size) {
		int minValue = INT_MAX;
		for (int i = 0; i < size; i++) {
			if (minValue > arr[i])
				minValue = arr[i];
		}
		return minValue;
	}
	int SumArray(int arr[], int size) {
		int sum = 0;
		for (int i = 0; i < size; i++) {
			sum += arr[i];
		}
		return sum;
	}
	float AvgOfArray(int arr[], int size) {
		return (float)SumArray(arr, size) / size;
	}
	void CopyArrOnlyPrimeNums(int arrSource[], int arrDestination[], int size1, int& size2) {
		int index = 0;
		for (int i = 0; i < size1; i++) {
			if (Math::CheckPrimeNumber(arrSource[i]) == Prime)
			{
				arrDestination[index] = arrSource[i];
				index++;
			}
		}
		size2 = index;

	}
	void SumTwoArrays(int arr1[], int arr2[], int arr3[], int size) {
		for (int i = 0; i < size; i++) {
			arr3[i] = arr1[i] + arr2[i];
		}
	}
	void PrintStringArray(string arr[], int size) {
		for (int i = 0; i < size; i++) {
			cout << "key [" << i + 1 << "] : " << arr[i] << endl;
		}
	}
	void ReadArrayOfKeys(string arr[], int size) {


		for (int i = 0; i < size; i++) {
			arr[i] = Random::GenerateKey();
		}
	}
	short FindNumberPositionInArray(int arr[], int num, int size) {
		for (int i = 0; i < size; i++) {
			if (arr[i] == num) {
				return i;
			}
		}
		// Not found
		return -1;
	}
	bool IsNumberInArray(int arr[], int number, int size) {

		return (FindNumberPositionInArray(arr, number, size) != -1);


	}
	void AddNumberToArray(int arr[], int& size, int number) {
		arr[size++] = number;
	}
	void AddNumbersToArray(int arr[], int& size) {

		bool AddMore = true;

		do
		{


			AddNumberToArray(arr, size, Read::ReadInt("Please enter a number ? \n","Invalid input\nPlease enter number : "));

			AddMore = Read::ReadIntInRange(0,1,"Do you want to add more numbers? [0]: No ,[1]: Yes ? \n", "Out of Range.\nPlease enter another number : ", "Invalid input\nPlease enter number : ");


		} while (AddMore);
	}
	void CopyArrayUsingAddNumberToArray(int arrSource[], int arrDestination[], int sizeSource, int& DestinationArraySize) {

		for (int i = 0; i < sizeSource; i++) {
			AddNumberToArray(arrDestination, DestinationArraySize, arrSource[i]);
		}

	}
	void CopyArray(int arrSource[], int arrDestination[], int size) {
		for (int i = 0; i < size; i++)
			arrDestination[i] = arrSource[i];
	}
	void CopyOddNumbers(int arrSource[], int arrDestination[], int sizeSource, int& sizeDestination) {


		for (int i = 0; i < sizeSource; i++) {
			if (arrSource[i] % 2 != 0)
				AddNumberToArray(arrDestination, sizeDestination, arrSource[i]);
		}

	}
	void CopyPrimeNumbers(int arrSource[], int arrDestination[], int sizeSource, int& sizeDestination) {
		for (int i = 0; i < sizeSource; i++) {
			if (Math::CheckPrimeNumber(arrSource[i]) == Prime)
			{
				AddNumberToArray(arrDestination, sizeDestination, arrSource[i]);
			}
		}
	}
	void CopyDistinctNumbers(int arrSource[], int arrDestination[], int sizeSource, int& sizeDestination) {
		for (int i = 0; i < sizeSource; i++) {
			if (!IsNumberInArray(arrDestination, arrSource[i], sizeDestination))
			{
				AddNumberToArray(arrDestination, sizeDestination, arrSource[i]);
			}
		}

	}
	bool IsPalindromeArray(int arr[], int size) {

		for (int i = 0; i < size; i++) {
			if (arr[i] != arr[size - i - 1]) {
				return false;
			}
		}
		return true;
	}
	int CountOddNumbersInArray(int arr[], int size) {
		int counter = 0;
		for (int i = 0; i < size; i++) {
			if (arr[i] % 2 != 0)
				counter += 1;
		}
		return counter;
	}
	int CountEvenNumbersInArray(int arr[], int size) {
		int counter = 0;
		for (int i = 0; i < size; i++) {
			if (arr[i] % 2 == 0)
				counter += 1;
		}
		return counter;
	}
	int CountPositiveNumbersInArray(int arr[], int size) {
		int counter = 0;
		for (int i = 0; i < size; i++) {
			if (arr[i] > 0)
				counter += 1;
		}
		return counter;
	}
	int CountNegativeNumbersInArray(int arr[], int size) {
		int counter = 0;
		for (int i = 0; i < size; i++) {
			if (arr[i] < 0)
				counter += 1;
		}
		return counter;
	}
	void ShuffleArray(int arr[], int size) {

		for (int i = 0; i < size; i++) {
			Utility::Swap(arr[Random::GenerateRandomNumber(0, size - 1)], arr[Random::GenerateRandomNumber(0, size - 1)]);
		}

	}
	void CopyArrayInReversedOrder(int arrSource[], int arrDestination[], int size) {
		for (int i = 0; i < size; i++) {
			arrDestination[i] = arrSource[(size - 1) - i];
		}
	}
	void FillArrayFrom1ToN(int arr[], int size) {

		for (int i = 0; i < size; i++)
			arr[i] = i + 1;
	}
	short MaxLenStringInArray(string arr[], int size) {
		short MaxLen = String::Len(arr[0]);
		for (int i = 1; i < size; i++) {
			if (String::Len(arr[i]) > MaxLen)
				MaxLen = String::Len(arr[i]);
		}
		return MaxLen;
	}

}

namespace File {
	
	void PrintFileContent(string PathToFile) {

		fstream file(PathToFile, ios::in);

		if (file.is_open()) {
			string line;
			while (getline(file, line))
				cout << line << '\n';
		}



	}

	void LoadDataFromFileToVector(string PathToFile, vector <string>& vFileContent) {
		fstream file(PathToFile, ios::in);
		if (file.is_open()) {
			string line;
			while (getline(file, line))
				vFileContent.push_back(line);
		}
	}

	void SaveVectorToFile(string PathToFile, vector <string>& vFileContent) {
		fstream file;
		file.open(PathToFile, ios::out);

		if (file.is_open()) {
			for (string& line : vFileContent)
				if (line != "")
					file << line << endl;
		}
	}

	void DeletRecordFromFile(string PathToFile, string DeletedRecord) {
		vector <string> FileContent;

		LoadDataFromFileToVector(PathToFile, FileContent);

		for (string& line : FileContent) {
			String::RemoveWordFromString(line, DeletedRecord);
		}

		SaveVectorToFile(PathToFile, FileContent);

	}

	void UpdateRecordInFile(string PathToFile, string record, string newRecord) {
		vector<string> FileContent;
		LoadDataFromFileToVector(PathToFile, FileContent);

		for (string& line : FileContent) {
			String::SwapWordInString(line, record, newRecord);
		}

		SaveVectorToFile(PathToFile, FileContent);

	}

	int CoutntFileRows(string fileName) {
		fstream file(fileName, ios::in);
		int counter = 0;
		string line;
		if (file.is_open())
		{
			while (getline(file, line))
				counter++;
		}
		return counter;


	}
}

namespace Table {

	const unsigned short width = 16;

	struct stTable {
		short cols, rows;
		string HeadLines[10];
		string Elements[10][10];
	};
	
	string GetBorder(short num) {
		string border = "|";
		for (int i = 0; i < num; i++)
			border += "-";
		border += "|";
		return border;
	}

	void ReadTable(stTable& table) {

		table.cols = Read::ReadIntInRange(1, 10, "How many Cols (1 - 10) ? ", "out of range.\n", "Invalid input.\n");
		table.rows = Read::ReadIntInRange(1, 10, "How many Rows (HeadLines are not included) (1 - 10) ? ", "out of range.\n", "Invalid input.\n");

		cin.ignore(INT_MAX, '\n');

		for (int i = 0; i < table.cols; i++) {
			cout << "Head Line " << i + 1 << " : ";
			getline(cin, table.HeadLines[i]);
		}

	}
	void ReadTableFromFile(stTable& table, string fileName, vector<string> headlines, string delimiter) {
		
		table.rows = File::CoutntFileRows(fileName);

		table.cols = headlines.size();

		for (short col = 0; col < table.cols; col++)
			table.HeadLines[col] = headlines[col];

	}
	
	void ReadTableElements(stTable& table) {
		for (int row = 0; row < table.rows; row++) {
			cout << "Row " << row + 1 << endl;
			for (int col = 0; col < table.cols; col++) {
				cout << table.HeadLines[col] << " : ";
				getline(cin, table.Elements[row][col]);
			}
		}
	}
	void ReadTableElementsFromFile(stTable& table, string fileName , string delimiter) {
		fstream file(fileName , ios::in);
		string line;
		if (file.is_open())
		{
			vector <string> fileLineElements;
			
			for (short row = 0; row < table.rows; row++) {
				getline(file, line);
				fileLineElements = String::SpliteString(line, delimiter);
				for (short col = 0; col < table.cols; col++) {
					table.Elements[row][col] = fileLineElements[col];
				}
			}
			
		}
	}
	
	void PrintTableBorder(stTable table) {
		for (int i = 0; i < table.cols; i++)
			cout << GetBorder(String::Len(table.HeadLines[i]) + width);
		cout << endl;
	}
	void PrintHeader(stTable table) {


		PrintTableBorder(table);

		for (int i = 0; i < table.cols; i++)
			cout << "|"<<Utility::GenerateSpaces(width / 2) << table.HeadLines[i] << Utility::GenerateSpaces(width / 2) <<"|";
		cout << endl;
		PrintTableBorder(table);


	}
	void PrintTableRow(stTable table, short row) {
		for (int col = 0; col < table.cols; col++) {
			
			//short totalHeadLineAligment = 8 + String::Len(table.HeadLines[col]);
			short totalHeadLineAligment = width + String::Len(table.HeadLines[col]);
			cout <<"|" << left << setw(totalHeadLineAligment) << table.Elements[row][col] << "|";
			
		}
		cout << endl;

	}
	void PrintTable(stTable& table) {
		PrintHeader(table);
		for (int row = 0; row < table.rows; row++)
		{
			PrintTableRow(table, row);
			PrintTableBorder(table);
		}
	}
	
	void CreatTable() {
		stTable table;
		ReadTable(table);
		ReadTableElements(table);
		PrintTable(table);
	}
	void CreatTableFromFile(string fileName, vector <string> headlines , string delimiter) {
		stTable table;
		ReadTableFromFile(table, fileName, headlines, delimiter);
		ReadTableElementsFromFile(table, fileName, delimiter);
		PrintTable(table);
	}
}

namespace Matrix {

	void PrintMatrix(int m[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < cols; j++)
				cout << setw(3) << m[i][j] << " ";
			cout << endl;
		}

	}
	void FillMatrixWithRandomNumbers(int m[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				m[i][j] = Random::GenerateRandomNumber(1, 100);
	}
	int RowSum(int m[100][100], int row, int cols) {
		int sum = 0;
		for (int i = 0; i < cols; i++)
			sum += m[row][i];
		return sum;
	}
	void PrintEachRowSum(int m[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++)
		{
			cout << "sum of row " << i + 1 << " : " << RowSum(m, i, cols) << endl;
		}



	}
	void SumMatrixRowsInArray(int m[100][100], int arr[], short rows, short cols) {
		for (int i = 0; i < rows; i++)
			arr[i] = RowSum(m, i, cols);
	}
	void PrintRowSumArray(int arr[], short rows) {
		for (int i = 0; i < rows; i++)
		{
			cout << "sum of row " << i + 1 << " : " << arr[i] << endl;
		}



	}
	int ColSum(int m[100][100], short rows, short col) {
		int sum = 0;
		for (int i = 0; i < rows; i++)
			sum += m[i][col];
		return sum;

	}
	void PrintEachColSum(int m[100][100], short rows, short cols) {

		for (int i = 0; i < cols; i++)
			cout << "sum of col " << i + 1 << " : " << ColSum(m, rows, i) << endl;

	}
	void SumMatrixColsInArray(int m[100][100], int arr[], short rows, short cols) {

		for (int i = 0; i < cols; i++)
			arr[i] = ColSum(m, rows, i);
	}
	void PrintColSumArray(int arr[], int cols) {
		for (int i = 0; i < cols; i++)
			cout << "Sum Of Col " << i + 1 << " : " << arr[i] << endl;

	}
	void FillMatrixWithOrderedNumbers(int m[100][100], short rows, short cols) {
		short num = 1;
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			{
				m[i][j] = num;
				num += 1;
			}
	}
	void TransposedMatrix(int m[100][100], short rows, short cols) {

		for (int i = 0; i < rows; i++)
			for (int j = i; j < cols; j++)
				Utility::Swap(m[i][j], m[j][i]);

	}
	void TransposedMatrix(int m[100][100], int TransposedMatrix[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				TransposedMatrix[j][i] = m[i][j];
			}
		}
	}
	void MultiplyTwoMatrices(int M1[100][100], int M2[100][100], int MResult[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				MResult[i][j] = M1[i][j] * M2[i][j];
	}
	void PrintMiddleRow(int m[100][100], short rows, short cols) {
		short middleRow = rows / 2;
		for (int i = 0; i < cols; i++)
			printf("%0*d ", 2, m[middleRow][i]);
	}
	void PrintMiddleCol(int m[100][100], short rows, short cols) {
		short middleCol = cols / 2;
		for (int i = 0; i < rows; i++)
			printf("%0*d ", 2, m[i][middleCol]);
	}
	int SumOfMatrix(int m[100][100], short rows, short cols) {
		int sum = 0;

		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				sum += m[i][j];

		return sum;

	}
	bool AreEquivalentMatrices(int m1[100][100], int m2[100][100], short rows, short cols) {
		return (SumOfMatrix(m1, rows, cols) == SumOfMatrix(m2, rows, cols));
	}
	bool AreEqualMatrices(int m1[100][100], int m2[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				if (m1[i][j] != m2[i][j])
					return false;
		return true;
	}
	bool IsIdentityMatrix(int m[100][100], short rows, short cols) {
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++) {
				if (i == j && m[i][j] != 1)
					return false;
				else if (i != j && m[i][j] != 0) {

					return false;
				}
			}
		return true;
	}
	bool IsScalarMatrix(int m[100][100], short rows, short cols) {
		int FirstDiagonalNumber = m[0][0];
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			{
				if (i == j && m[i][j] != FirstDiagonalNumber)
					return false;
				else if (i != j && m[i][j] != 0)
					return false;
			}
		return true;
	}
	short CountNumberInMatrix(int m[100][100], int NumToCount, short rows, short cols) {
		unsigned short counter = 0;

		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				if (m[i][j] == NumToCount)
					counter += 1;

		return counter;
	}
	bool IsSparseMatrix(int m[100][100], short rows, short cols) {
		unsigned short MatrixSize = rows * cols;
		return (CountNumberInMatrix(m, 0, rows, cols) > (MatrixSize / 2));
	}
	bool IsNumberInMatrix(int m[100][100], int NumToFind, short rows, short cols) {
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				if (m[i][j] == NumToFind)
					return true;
		return false;
	}
	void PrintCommonNumbersInMatrices(int m1[100][100], int m2[100][100], short rows, short cols) {
		short Number;
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			{
				Number = m2[i][j];
				if (IsNumberInMatrix(m1, Number, rows, cols))
					cout << Number << " ";
			}

	}
	int MaxNumberInMatrix(int m[100][100], short rows, short cols)
	{
		short MaxNumber = m[0][0];
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				if (m[i][j] > MaxNumber)
					MaxNumber = m[i][j];
		return MaxNumber;
	}
	int MinNumberInMatrix(int m[100][100], short rows, short cols)
	{
		short MinNumber = m[0][0];
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
				if (m[i][j] < MinNumber)
					MinNumber = m[i][j];
		return MinNumber;
	}
	bool IsPalindromeMatrix(int m[100][100], short rows, short cols)
	{
		for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols / 2; j++)
				if (m[i][j] != m[i][cols - 1 - j])
					return false;
		return true;
	}

}

namespace Client {
	const string ClientsFileName = "clients.txt";

	struct stClient {
		string name;
		string pinCode;
		string phoneNumber;
		string accountNumber;
		bool MarkForDelete = false; // flag
		double accountBalance;
	};

	stClient ReadNewClient() {
		stClient client;
		client.accountNumber = Read::ReadString("Enter Account Number ? ");
		client.pinCode = Read::ReadString("Enter PinCode ? ");
		client.name = Read::ReadString("Enter Name ? ");
		client.phoneNumber = Read::ReadString("Enter Phone Number ? ");
		client.accountBalance = Read::ReadDouble("Enter AccountBalance ? ", "invalid input.\n");
		return client;
	}
	string ConvertRecordToLine(const stClient& client, string seperator = "#//#") {
		string ClientRecord = "";
		ClientRecord += client.accountNumber + seperator;
		ClientRecord += client.pinCode + seperator;
		ClientRecord += client.name + seperator;
		ClientRecord += client.phoneNumber + seperator;
		ClientRecord += to_string(client.accountBalance);
		return ClientRecord;
	}
	stClient ConvertLineToRecord(string record, string seperator = "#//#") {
		stClient client;

		vector <string> vRecord = String::SpliteString(record, seperator);

		client.accountNumber = vRecord.at(0);
		client.pinCode = vRecord.at(1);
		client.name = vRecord.at(2);
		client.phoneNumber = vRecord.at(3);
		client.accountBalance = stod(vRecord.at(4));

		return client;


	}
	void PrintClientCard(stClient client) {
		cout << "name             : " << client.name << endl;
		cout << "pin code         : " << client.pinCode << endl;
		cout << "phone number     : " << client.phoneNumber << endl;
		cout << "account number   : " << client.accountNumber << endl;
		cout << "account balance  : " << client.accountBalance << endl;
	}
	void AddDataLineToFile(string FileName, string DataLine) {
		fstream file(FileName, ios::app | ios::out);
		if (file.is_open())
		{
			file << DataLine << endl;
			file.close();
		}
	}
	void AddNewClient() {

		stClient client = ReadNewClient();

		AddDataLineToFile(ClientsFileName, ConvertRecordToLine(client));

	}
	void AddClients() {
		char NewClient = 'y';
		do {
			system("clear");
			AddNewClient();
			NewClient = Read::ReadChar("added successfully , do you want to add new client (y) (n) ? ");
		} while (String::ToLower(NewClient) == 'y');
	}
	void MyShowAllClients() {


		vector <string> headLines = { "account number" ,"pin code" ,"name" ,"phone number", "account balance" };

		Table::CreatTableFromFile(ClientsFileName, headLines, "#//#");

	}
	
	void PrintHeader() {
		cout << "\t\t\t\t\tClinet List (" << File::CoutntFileRows(ClientsFileName) << ") Client(s).\n";

		cout << Utility::GenerateDashes(98) << endl << endl;

		cout << "| " << left << setw(15) << "Account Number" << "| ";
		cout << left << setw(10) << "Pin Code" << "| ";
		cout << left << setw(41) << "Client Name" << "| ";
		cout << left << setw(14) << "Phone" << "| ";
		cout << left << setw(14) << "Balance" << endl;

		cout << Utility::GenerateDashes(98) << endl << endl;
	}
	vector<stClient> LoadClientsDataFromFileToVector(string fileName) {
		vector <stClient> vClients;
		fstream file(fileName, ios::in);
		if (file.is_open()) {

			stClient client;
			string line;

			while (getline(file, line)) {
				client = ConvertLineToRecord(line);
				vClients.push_back(client);
			}
			file.close();
		}
		return vClients;
	}
	void PrintClientData(stClient client) {

		cout << "| " << left << setw(15) << client.accountNumber << "| ";
		cout << left << setw(10) << client.pinCode << "| ";
		cout << left << setw(41) << client.name << "| ";
		cout << left << setw(14) << client.phoneNumber << "| ";
		cout << client.accountBalance << endl;

	}
	void PrintAllClientsData(vector <stClient> vClients) {
		PrintHeader();

		for (stClient& client : vClients)
			PrintClientData(client);
		cout << Utility::GenerateDashes(98) << endl;
	}
	bool FindClientByAccountNumber(string AccountNumber, const vector <stClient>& vClients, stClient& client) {

		for (const stClient& C : vClients) {
			if (C.accountNumber == AccountNumber)
			{
				client = C;
				return true;
			}
		}
		return false;

	}
	void LoadClientsDataFromVectorToFile(string fileName, vector <stClient> clients) {
		fstream file(fileName, ios::out); // overwrite

		if (file.is_open()) {
			for (const stClient& client : clients) {
				if (!client.MarkForDelete)
					file << ConvertRecordToLine(client) << endl;

			}
			file.close();
		}
	}
	void MarkClientForDelete(vector <stClient>& Clients, const stClient& client) {

		for (stClient& C : Clients) {
			if (C.accountNumber == client.accountNumber)
			{
				C.MarkForDelete = true;
				return;
			}
		}


	}
	void DeleteClientByAccountNumber(vector <stClient> Clients, string AccoutNumber) {

		stClient client;

		if (FindClientByAccountNumber(AccoutNumber, Clients, client)) {

			cout << "The following are the client details : \n\n";

			PrintClientCard(client);

			char WantToDelete = Read::ReadChar("Are you sure you want to delete this account (y) (n) ? ");

			if (String::ToLower(WantToDelete) == 'y') {

				MarkClientForDelete(Clients, client);

				LoadClientsDataFromVectorToFile(ClientsFileName, Clients);

				// refresh Clients vector
				Clients = LoadClientsDataFromFileToVector(ClientsFileName);

				cout << "Client Deleted Successfully.\n\n";

			}
		}

		else {
			cout << "Not found :-(" << endl;
		}




	}
	stClient UpdateClientRecored(string AccountNumber) {
		stClient client;
		client.accountNumber = AccountNumber;
		client.pinCode = Read::ReadString("\n\nEnter pin code : ");
		client.name = Read::ReadString("Enter name : ");
		client.phoneNumber = Read::ReadString("Enter phone number : ");
		client.accountBalance = Read::ReadDouble("Enter account balance : ");
		return client;

	}
	void UpdateCleintByAccountNumber(vector <stClient>& Clients, string AccountNumber) {
		stClient client;

		if (FindClientByAccountNumber(AccountNumber, Clients, client)) {

			cout << "The following is the client's details : \n";

			PrintClientCard(client);
			char WantToDelete = Read::ReadChar("Are you sure you want to update client's details (y) (n) ? ");
			if (String::ToLower(WantToDelete)) {
				for (stClient& C : Clients) {
					if (C.accountNumber == AccountNumber)
					{
						C = UpdateClientRecored(AccountNumber);
						break;
					}
				}
			}

			LoadClientsDataFromVectorToFile(ClientsFileName, Clients);
		}

		else {
			cout << "Not Found :-(\n\n";
		}

	}

}

namespace Problem {

	bool IsLeapYear(short year) {
		return (year % 400 == 0) || (year % 100 != 0 && year % 4 == 0);
	}

	short NumberOfDaysInYear(short year) {
		return IsLeapYear(year) ? 366 : 365;
	}
	short NumberOfHoursInYear(short year) {
		return NumberOfDaysInYear(year) * 24;
	}
	int NumberOfMinutesInYear(short year) {
		return NumberOfHoursInYear(year) * 60.f;
	}
	int NumberOfSecondsInYear(short year) {
		return NumberOfMinutesInYear(year) * 60.f;
	}


	short NumberOfDaysInMonth(short month, short year) {

		//short MonthsWith31Day[] = {1,3,5,7,8,10,12};

		if (month > 12 || month < 1)
			return 0;
		short DaysInMonth[12] = { 31,28 ,31 ,30,31,30,31,31,30,31,30, 31 };

		return month == 2 ? (IsLeapYear(year) ? 29 : 28) : DaysInMonth[month - 1];

	}
	short NumberOfHoursInMonth(short month, short year) {

		return NumberOfDaysInMonth(month, year) * 24;

	}
	int NumberOfMinutesInMonth(short month, short year) {
		return NumberOfHoursInMonth(month, year) * 60;
	}
	int NumberOfSecondsInMonth(short month, short year) {
		return NumberOfMinutesInMonth(month, year) * 60;
	}

	void PrintDate(short day, short month, short year) {
		cout << day << " / " << month << "/" << year << endl;
	}

	short DayOfWeekOrder(short day, short month, short year) {

		short a = (14 - month) / 12;
		short y = year - a;
		short m = month + 12 * a - 2;
		short d = (int)(day + y + (y / 4) - (y / 100) + (y / 400) + ((31 * m) / 12)) % 7;

		return d;

	}

	string DayName(short DayOrder) {
		string days[] = { "sunday", "monday", "tuesday", "wednesday","thursday", "friday" , "saturday" };
		return days[DayOrder];
	}


}

namespace Date {
	struct stDate {
		short day;
		short month;
		int year;
	};
	struct stPeriod {
		stDate StartDate;
		stDate EndDate;
	};

	bool IsLeapYear(int year) {
		return (year % 400 == 0) || (year % 100 != 0 && year % 4 == 0);
	}
	short NumberOfDaysInYear(int year) {
		return IsLeapYear(year) ? 366 : 365;
	}
	short NumberOfHoursInYear(int year) {
		return NumberOfDaysInYear(year) * 24;
	}
	int NumberOfMinutesInYear(int year) {
		return NumberOfHoursInYear(year) * 60.f;
	}
	int NumberOfSecondsInYear(int year) {
		return NumberOfMinutesInYear(year) * 60.f;
	}


	short NumberOfDaysInMonth(short month, int year) {


		if (month > 12 || month < 1)
			return 0;
		short DaysInMonth[12] = { 31,28 ,31 ,30,31,30,31,31,30,31,30, 31 };

		return month == 2 ? (IsLeapYear(year) ? 29 : 28) : DaysInMonth[month - 1];

	}
	short NumberOfHoursInMonth(short month, int year) {

		return NumberOfDaysInMonth(month, year) * 24;

	}
	int NumberOfMinutesInMonth(short month, int year) {
		return NumberOfHoursInMonth(month, year) * 60;
	}
	int NumberOfSecondsInMonth(short month, int year) {
		return NumberOfMinutesInMonth(month, year) * 60;
	}


	short DayOfWeekOrder(short day, short month, int year) {

		short a = (14 - month) / 12;
		short y = year - a;
		short m = month + 12 * a - 2;
		short d = (int)(day + y + (y / 4) - (y / 100) + (y / 400) + ((31 * m) / 12)) % 7;

		return d;

	}
	short DayOfWeekOrder(stDate date) {

		return DayOfWeekOrder(date.day, date.month, date.year);

	}

	string DayName(short DayOrder) {
		string days[] = { "sunday", "monday", "tuesday", "wednesday","thursday", "friday" , "saturday" };
		return days[DayOrder];
	}
	string DayShortName(short DayOrder) {
		string days[] = { "Sun", "Mon", "Tue", "Wed","Thu", "Fri" , "Sat" };
		return days[DayOrder];
	}


	string MonthShortName(short month) {
		string months[] = { "Jan", "Feb" ,"Mar" , "Apr" , "May", "Jun", "Jul", "Aug","Sep", "Oct", "Nov","Dec" };

		return months[month - 1];
	}
	
	void PrintMonthCalender(short month, int year) {

		short FirstDay = DayOfWeekOrder({ 1, month, year });
		short NumberOfDays = NumberOfDaysInMonth(month, year);

		printf("________________%s________________\n\n", MonthShortName(month).c_str());
		printf("  sun  mon  tue  wed  thu  fri  sat\n");
		int i;
		for (i = 0; i < FirstDay; i++)
			cout << "     ";

		for (int j = 1; j <= NumberOfDays; j++) {
			printf("%5d", j);

			if (++i == 7)
			{
				cout << endl;
				i = 0;
			}
		}
		printf("\n___________________________________\n");



	}
	void PrintYearCalender(int year) {
		cout << "___________________________________\n\n";
		cout << "            " << year << " - calender\n";
		cout << "___________________________________\n\n";
		for (short month = 1; month <= 12; month++) {
			PrintMonthCalender(month, year);
			cout << endl;
		}
	}


	short TotalDaysFromTheBegingOfYear(short day, short month, int year) {
		short TotalDays = 0;
		for (short m = 1; m < month; m++)
			TotalDays += NumberOfDaysInMonth(m, year);
		TotalDays += day;
		return TotalDays;
	}
	short TotalDaysFromTheBegingOfYear(stDate date) {

		return TotalDaysFromTheBegingOfYear(date.day, date.month, date.year);
	}
	
	stDate GetDateFromDayOrderInWeek(short days, int year) {

		stDate Date;

		Date.year = year;
		Date.month = 1;
		short RemainingDays = days;

		short DaysInMonth;
		while (true) {
			DaysInMonth = NumberOfDaysInMonth(Date.month, year);
			if (RemainingDays > DaysInMonth) {

				RemainingDays -= DaysInMonth;
				Date.month++;

			}
			else {
				Date.day = RemainingDays;
				break;

			}
		}

		return Date;

	}
	stDate AddDaysToDate(short days, stDate date) {

		int remainingDays = days + TotalDaysFromTheBegingOfYear(date);

		date.month = 1;
		short MonthDays;
		while (true) {

			MonthDays = NumberOfDaysInMonth(date.month, date.year);
			if (remainingDays < MonthDays) {

				date.day = (remainingDays == 0 ? remainingDays + 1 : remainingDays);
				break;
			}

			else {
				remainingDays -= MonthDays;
				date.month++;
				if (date.month > 12) {
					date.month = 1;
					date.year++;
				}

			}
		}
		return date;
	}
	
	stDate ReadDate() {
		stDate date;
		date.year = Read::ReadIntInRange(0, INT_MAX, "Enter year : ");
		date.month = Read::ReadIntInRange(1, 12, "Enter month : ");
		date.day = Read::ReadIntInRange(1, NumberOfDaysInMonth(date.month, date.year), "Enter day : ");
		return date;
	}
	stPeriod ReadPeriod() {
		cout << "Enter period" << endl;
		stDate DateFrom = ReadDate();
		stDate DateTo = ReadDate();
		stPeriod Period = { DateFrom, DateTo };
		return Period;
	}
	stDate FillRandomDate() {
		stDate date;
		date.year = Random::GenerateRandomNumber(1, INT_MAX);
		date.month = Random::GenerateRandomNumber(1, 12);
		date.day = Random::GenerateRandomNumber(1, NumberOfDaysInMonth(date.month, date.year));
		return date;
	}
	
	bool IsDate1BeforeDate2(stDate date1, stDate date2) {
		return (date1.year < date2.year) ? true : ((date1.year == date2.year) ? ((date1.month < date2.month) ? true : ((date1.month == date2.month) ? ((date1.day < date2.day) ? true : false) : false)) : false);
	}
	bool IsDate1EqualsToDate2(stDate date1, stDate date2) {
		return (date1.year == date2.year) && (date1.month == date2.month) && (date1.day == date2.day);
	}
	bool IsDate1AfterDate2(stDate date1, stDate date2) {
		return (!IsDate1BeforeDate2(date1, date2) && !IsDate1EqualsToDate2(date1, date2));
	}
	bool IsLastDayInMonth(stDate date) {
		return date.day == NumberOfDaysInMonth(date.month, date.year) ? true : false;
	}
	bool IsLastMonthInYear(stDate date) {
		return (date.month == 12);
	}
	bool IsEndOfWeek(stDate date) {

		return (DayOfWeekOrder(date) == 6);
	}
	bool IsWeekEnd(stDate date) {
		short dayOrder = DayOfWeekOrder(date);
		return  dayOrder == 5 || dayOrder == 6;
	}
	bool IsBusinessDay(stDate date) {
		return !IsWeekEnd(date);
	}

	stDate GetTodayDate() {

		long long t = time(0);
		tm* now = localtime(&t);

		stDate TodayDate;

		TodayDate.year = now->tm_year + 1900;
		TodayDate.month = now->tm_mon + 1;
		TodayDate.day = now->tm_mday;

		return TodayDate;
	}
	
	void SwapDates(stDate& date1, stDate& date2) {
		stDate temp;
		temp.day = date1.day;
		temp.month = date1.month;
		temp.year = date1.year;

		date1.day = date2.day;
		date1.month = date2.month;
		date1.year = date2.year;

		date2.day = temp.day;
		date2.month = temp.month;
		date2.year = temp.year;




	}
	void SwapPeriods(stPeriod& period1, stPeriod& period2) {
		stPeriod temp;

		temp.StartDate = period1.StartDate;
		temp.EndDate = period1.EndDate;

		period1.StartDate = period2.StartDate;
		period1.EndDate = period2.EndDate;

		period2.StartDate = temp.StartDate;
		period2.EndDate = temp.EndDate;

	}


	stDate IncreaseDateByOneDay(stDate date) {
		if (IsLastDayInMonth(date))
		{
			if (IsLastMonthInYear(date))
			{
				date.year++;
				date.day = date.month = 1;
			}
			else {
				date.month++;
				date.day = 1;
			}

		}
		else {
			date.day++;
		}
		return date;
	}
	stDate IncreaseDateByOneWeek(stDate date) {

		for (short i = 1; i <= 7; i++)
			date = IncreaseDateByOneDay(date);
		return date;
	}
	stDate IncreaseDateByOneMonth(stDate date) {

		if (date.month == 12)
		{
			date.year++;
			date.month = 1;
		}
		else {
			date.month++;
		}
		short DaysInCurrentMonth = NumberOfDaysInMonth(date.month, date.year);
		if (date.day > DaysInCurrentMonth)
			date.day = DaysInCurrentMonth;

		return date;

	}
	stDate IncreaseDateByOneYear(stDate date) {
		date.year++;
		return date;
	}
	stDate IncreaseDateByOneDecade(stDate date) {
		date.year += 10;
		return date;
	}
	stDate IncreaseDateByOneCentury(stDate date) {
		date.year += 100;
		return date;
	}
	stDate IncreaseDateByOneMillennium(stDate date) {
		date.year += 1000;
		return date;
	}
	stDate IncreaseDateByXWeeks(int weeksToAdd, stDate date) {
		for (int i = 0; i < weeksToAdd; i++)
			date = IncreaseDateByOneWeek(date);
		return date;
	}
	stDate IncreaseDateByXMonths(int MonthsToAdd, stDate date) {
		for (int i = 0; i < MonthsToAdd; i++)
			date = IncreaseDateByOneMonth(date);
		return date;
	}
	stDate IncreaseDateByXYears(int yearsToAdd, stDate date) {
		date.year += yearsToAdd;
		return date;
	}
	stDate IncreaseDateByXDecades(int DecadesToAdd, stDate date) {
		date.year += (DecadesToAdd * 10);
		return date;
	}


	stDate DecreaseDateByOneDay(stDate date) {

		if (date.day == 1) {
			if (date.month == 1) {
				date.month = 12;
				date.year--;
			}

			else {
				date.month--;
			}

			date.day = NumberOfDaysInMonth(date.month, date.year);
		}
		else {
			date.day--;
		}


		return date;
	}
	stDate DecreaseDateByOneWeek(stDate date) {

		for (short i = 0; i < 7; i++) {
			date = DecreaseDateByOneDay(date);
		}

		return date;
	}
	stDate DecreaseDateByOneMonth(stDate date) {
		if (date.month == 1)
		{
			date.year--;
			date.month = 12;
		}

		else
		{
			date.month--;
		}
		short MonthDays = NumberOfDaysInMonth(date.month, date.year);

		if (date.day > MonthDays)
			date.day = MonthDays;

		return date;

	}
	stDate DecreaseDateByOneYear(stDate date) {
		date.year--;
		return date;
	}
	stDate DecreaseDateByOneDecade(stDate date) {
		date.year -= 10;
		return date;
	}
	stDate DecreaseDateByOneCentury(stDate date) {
		date.year -= 100;
		return date;
	}
	stDate DecreaseDateByOneMillennium(stDate date) {
		date.year -= 1000;
		return date;
	}
	stDate DecreaseDateByXDays(int DaysToDecrease, stDate date) {
		for (int i = 0; i < DaysToDecrease; i++)
			date = DecreaseDateByOneDay(date);
		return date;
	}
	stDate DecreaseDateByXWeeks(int WeeksToDecrease, stDate date) {
		for (int i = 0; i < WeeksToDecrease; i++)
			date = DecreaseDateByOneWeek(date);
		return date;
	}
	stDate DecreaseDateByXMonths(int MonthsToDecrease, stDate date) {
		for (int i = 0; i < MonthsToDecrease; i++)
			date = DecreaseDateByOneMonth(date);
		return date;
	}
	stDate DecreaseDateByXYears(int YearsToDecrease, stDate date) {
		date.year += YearsToDecrease;
		return date;
	}
	stDate DecreaseDateByXDecades(int DecadesToDecrease, stDate date) {
		date.year += (10 * DecadesToDecrease);
		return date;
	}

	int GetDifferenceInDays(stDate date1, stDate date2, bool IncludeEndDay = false) {
		int days = 0;
		short flag = 1;
		if (!IsDate1BeforeDate2(date1, date2)) {
			SwapDates(date1, date2);
			flag *= -1;
		}

		while (IsDate1BeforeDate2(date1, date2)) {
			days++;
			date1 = IncreaseDateByOneDay(date1);
		}


		return IncludeEndDay ? ++days * flag : days * flag;

	}

	
	short DaysUntilEndOfWeek(stDate date) {
		return 6 - DayOfWeekOrder(date);
	}
	short DaysUntilEndOfMonth(stDate date) {

		stDate EndOfMonthDate = { NumberOfDaysInMonth(date.month,date.year) , date.month , date.year };

		return GetDifferenceInDays(EndOfMonthDate, date, true);

		//another code 
		/*
		short DaysInMonth = NumberOfDaysInMonth(date.month, date.year);
		return (DaysInMonth - date.day) + 1;
		*/


	}
	short DaysUntilEndOfYear(stDate date) {

		stDate EndOfYearDate = { 31,12,date.year };
		return GetDifferenceInDays(EndOfYearDate, date, true);
		// another code
		/*
		return (NumberOfDaysInYear(date.year) - TotalDaysFromTheBegingOfYear(date)) + 1;*/

	}
	void PrintDateAndDay(stDate date) {
		string day = DayName(DayOfWeekOrder(date));
		cout << "Today is " << day << " , " << date.day << "/" << date.month << "/" << date.year << endl;
	}

	int CountVacationDays(stDate DateFrom, stDate DateTo) {
		int VacatoinDaysCount = 0;
		while (!IsDate1EqualsToDate2(DateFrom, DateTo)) {
			if (IsBusinessDay(DateFrom))
				VacatoinDaysCount++;
			DateFrom = IncreaseDateByOneDay(DateFrom);
		}
		return VacatoinDaysCount;
	}
	stDate CalculateReturnDate(stDate DateFrom, int VacationDays) {


		int WeekEndsCounter = 0;

		for (int i = 1; i <= VacationDays + WeekEndsCounter; i++) {
			if (IsWeekEnd(DateFrom))
				WeekEndsCounter++;
			DateFrom = IncreaseDateByOneDay(DateFrom);
		}

		return DateFrom;

	}


	enum enDateCompare { Before = -1, Equal, After };
	enDateCompare CompareDate(stDate date1, stDate date2) {
		// Before -1
		// equal 0
		// after 1

		if (IsDate1BeforeDate2(date1, date2))
			return Before;
		if (IsDate1EqualsToDate2(date1, date2))
			return Equal;

		return After;

	}
	
	bool IsOverlapPeriods(stPeriod period1, stPeriod period2) {


		//if (
		//	CompareDate(period1.StartDate, period2.EndDate) == Before
		//	||
		//	CompareDate(period1.StartDate, period2.EndDate) == After
		//	)
		//	return false;
		//return true;

		return !(CompareDate(period1.StartDate, period2.EndDate) == After || CompareDate(period1.EndDate, period2.StartDate) == Before);

	}
	int CalculatePeriodLenght(stPeriod period, bool IncludeEndDay = false) {


		return GetDifferenceInDays(period.StartDate, period.EndDate, IncludeEndDay);


	}
	bool IsDateWithinPeriod(stPeriod period, stDate date) {
		return !(
			CompareDate(period.StartDate, date) == After
			||
			CompareDate(period.EndDate, date) == Before
			);
	}

	int CountOverlapDays(stPeriod period1, stPeriod period2) {

		if (!IsOverlapPeriods(period1, period2))
			return 0;

		int overlapDays = 0;

		if (CalculatePeriodLenght(period1) < CalculatePeriodLenght(period2))
			SwapPeriods(period1, period2);

		if (IsDateWithinPeriod(period1, period2.StartDate) && IsDateWithinPeriod(period1, period2.EndDate))
			overlapDays = CalculatePeriodLenght(period2);

		else if (IsDateWithinPeriod(period1, period2.StartDate))
			overlapDays = CalculatePeriodLenght({ period2.StartDate, period1.EndDate });

		else if (IsDateWithinPeriod(period2, period1.StartDate))
			overlapDays = CalculatePeriodLenght({ period1.StartDate, period2.EndDate });

		return overlapDays + 1;

	}
	bool IsValidDate(stDate date) {

		// NumberOfDaysInMonth will return 0 if the month is out of range

		return (date.year > 0) && (date.day > 0) && (date.day <= NumberOfDaysInMonth(date.month, date.year));

	}
	stDate StringToDate(string DateInString) {

		vector <string> vDate = String::SpliteString(DateInString, "/");

		if (vDate.size() != 3)
			return {};

		stDate Date = { stoi(vDate.at(0)) , stoi(vDate.at(1)) , stoi(vDate.at(2)) };

		return Date;
	}
	string DateToString(stDate Date) {

		return to_string(Date.day) + '/' + to_string(Date.month) + '/' + to_string(Date.year);

	}
	string FormatDate(stDate date, string FormatDate = "dd/mm/yyyy") {

		FormatDate = String::ReplaceWordInString(FormatDate, "dd", to_string(date.day));
		FormatDate = String::ReplaceWordInString(FormatDate, "mm", to_string(date.month));
		FormatDate = String::ReplaceWordInString(FormatDate, "yyyy", to_string(date.year));

		return FormatDate;

	}

}
